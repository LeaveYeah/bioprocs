#!/usr/bin/env python
import sys
from pyppl import PyPPL, utils

def help(error = None, quit = True):
	h  = []
	if error:
		h.append(error + '\n')
	h.append("USAGE:")
	h.append("  proc <mod.proc> [options ...]")
	h.append("  The process <mod.pProc> will be used.\n")
	h.append("OPTIONS:")
	h.append("  -xxx                     Set the attribute of mod.pProc")
	h.append("  -input.xxx, -in.xxx      Set the input data")\
	# TODO
	#h.append("  -output.xxx, -out.xxx    Set the output data")
	h.append("  -args.xxx                Set the arguments of mod.pProc")
	h.append("  -proc.xxx                Set the config option of the pipeline")
	sys.stderr.write("\n".join(h) + "\n")
	if quit: exit(1)

def arg2PyVar(var):
	# TODO: python3 compatibility
	if isinstance(var, str):
		var = var.replace('\\n', '\n')
		var = var.replace('\\t', '\t')
		if var.startswith('repr:'):
			var = eval(var[5:])
	return var

def arbitraryArgs():
	argv = sys.argv[1:]
	if (len(argv) == 0):
		help()
	ret     = {}
	modproc = argv.pop(0).split('.')
	ret['_module'] = 'bioprocs.{mod}'.format(mod = modproc[0])
	ret['_proc']   = 'p{proc}'.format(proc = modproc[1][0].upper() + modproc[1][1:])
	argname = None
	for arg in argv:
		if argname and arg.startswith('-'):
			ret[argname] = True
			argname = arg[1:]
		elif argname and not arg.startswith('-'):
			ret[argname] = arg2PyVar(arg)
			argname = None
		elif not argname and arg.startswith('-'):
			argname = arg[1:]
		else:
			sys.stderr.write('WARNING: Do not know which option this value (%s) belongs to.\n' % arg)
	return ret

def composeProc(args):
	if '_module' not in args or '_proc' not in args:
		help('ERROR: No process specified.')

	if not any([key.startswith('input.') or key.startswith('in.') for key in args.keys()]):
		help('ERROR: Input data is required (-input.xxx or -in.xxx)')

	module = args['_module']
	pname  = args['_proc']
	proc = getattr(__import__(module, fromlist = ['bioprocs']), pname)
	del args['_module']
	del args['_proc']
	config = {'proc': {}}
	if isinstance(proc.config['input'], dict):
		inkeys = inkeys.keys()
	else:
		inkeys = utils.split(proc.config['input'], ',')
	inkeys = [inkey.split(':')[0] for inkey in inkeys]
	input = [''] * len(inkeys)
	
	for key, val in args.items():
		if '.' not in key:
			setattr(proc, key, val)
		kparts = key.split('.')
		t = kparts.pop(0)
		if t == 'input' or t == 'in':
			inkey = kparts[0]
			if not inkey in inkeys:
				help('ERROR: Unknown input key ({}) for ({}.{}), expect [{}]'.format(inkey, module, pname, ', '.join(inkeys)))
			input[inkeys.index(inkey)] = val
		elif t == 'args':
			lastpart = kparts.pop(-1)
			aval = proc.args
			for k in kparts:
				if k not in aval:
					aval[k] = {}
				aval = aval[k]
			if lastpart not in aval:
				lastpart = lastpart.replace('-', '.')
			aval[lastpart] = val
		elif t == 'proc':
			lastpart = kparts.pop(-1)
			procconf = config['proc']
			for k in kparts:
				if k not in procconf:
					procconf[k] = {}
				else:
					procconf = procconf[k]
			procconf[lastpart] = val
	setattr(proc, 'input', input)
	return proc, config

if __name__ == '__main__':
	args = arbitraryArgs()
	proc, config = composeProc(args)
	PyPPL(config).start(proc).run()
