#!/usr/bin/env python
"""
The main program entrance for bioprocs binaries.
"""

import re, textwrap, imp
import inspect
import sys
from os import path, listdir
from collections import OrderedDict
from pyppl import PyPPL, utils
import six
import bioprocs

KEYLEN_MIN = 30
DOCLEN_MAX = 100


class Command(object):

	@staticmethod
	def printDocs(docs, preflen = 0, maxlen = DOCLEN_MAX, hyphen = True):
		newlines = []
		for line in docs:
			if len(line) <= maxlen:
				newlines.append(line)
			else:
				newlines.extend(textwrap.wrap(line, maxlen))
		prefix1 = '- ' if hyphen else ''
		prefix2 = '  ' if hyphen else ''
		return '\n'.join([
			prefix1 + line if i == 0 else prefix2 + (' ' * preflen) + line
			for i, line in enumerate(newlines)
		])

	@staticmethod	
	def getitems(optstr):
		ret = OrderedDict()
		optlines = optstr.splitlines()
		for optline in optlines:
			optline = optline.lstrip()
			nmatch  = re.match(r'(`)([:\.\w]+)\1\s*:\s*(.+)', optline)
			if nmatch:
				optname = nmatch.group(2).split(':')[0]
				optdoc1 = nmatch.group(3)
				if not optname in ret:
					ret[optname] = [optdoc1]
			elif ret:
				optname = list(ret.keys())[-1]
				ret[optname].append(optline)
		return ret

	@staticmethod
	def getblocks(docstr):
		lines = docstr.splitlines()
		blockname = None
		ret = {}
		for line in lines:
			if not line.strip(): continue
			line = line.lstrip('\t')
			namematch = re.match(r'^@(\w+):', line)
			if not namematch and not blockname:
				blockname = 'doc'
				ret[blockname] = line + '\n'
			elif namematch:
				blockname = namematch.group(1)
				ret[blockname] = ''
			else:
				ret[blockname] += line + '\n'
		return ret

	def __init__(self, name, prog = path.basename(sys.argv[0])):
		self.prog   = prog
		self.name   = name
		self._doc   = []
		self._usage = []
		self._opts  = OrderedDict()

		docstr = self._getDocString()
		self._fromDocstr(docstr)

	def _fromDocstr(self, docstr):
		blocks     = Command.getblocks(docstr)
		self.doc   = blocks.get('doc', '')
		self.usage = blocks.get('usage', '')
		self.opts  = Command.getitems(blocks.get('params', ''))

	def _getDocString(self):
		raise NotImplementedError()

	def _replaceholders(self, s):
		return s.replace('{prog}', self.prog).replace('{name}', self.name)

	def _error(self, error = '', help = True, exit = True):
		ret = '\n'
		if error:
			if not isinstance(error, list):
				error = error.splitlines()
			ret += 'Error: ' + Command.printDocs(error, 7, hyphen = False) + '\n'
		if help:
			ret += self.help()
		sys.stderr.write(ret)
		if exit:
			sys.exit(1)

	@property
	def doc(self):
		return self._doc

	@doc.setter
	def doc(self, docs):
		if not isinstance(docs, list):
			docs = docs.splitlines()
		for d in docs:
			if not d.strip(): continue
			self._doc.append(self._replaceholders(d.lstrip('\t')))
	
	@property
	def usage(self):
		return self._usage
	
	@usage.setter
	def usage(self, usages):
		if not isinstance(usages, list):
			usages = usages.splitlines()
		for u in usages:
			if not u.strip(): continue
			self._usage.append(self._replaceholders(u.lstrip('\t')))

	@property
	def opts(self):
		return self._opts
	
	@opts.setter
	def opts(self, argitem):
		if isinstance(argitem, dict):
			for item in argitem.items():
				self.opts = item
		else:
			argname, argvalue = argitem
			if not argname in self._opts:
				self._opts[argname] = []
			if not isinstance(argvalue, list):
				argvalue = argvalue.splitlines()
			for av in argvalue:
				if not av.strip(): continue
				self._opts[argname].append(self._replaceholders(av.lstrip('\t')))
	
	def help(self):
		ret  = '\n'
		ret += '%s\n\n' % Command.printDocs(self.doc, hyphen = False)

		if self.usage:
			ret += 'Usage:\n'
			ret += '  %s\n' % Command.printDocs(self.usage, 2, hyphen = False)
			ret += '\n'

		ret += 'Options:\n'
		keylen = max([len(key) for key in self.opts.keys()]) if self.opts else 0
		keylen = max(KEYLEN_MIN, keylen)
		fmtstr = '  %-' + str(keylen) + 's%s\n'
		for optname, optdoc in self.opts.items():
			ret += fmtstr % (optname, Command.printDocs(optdoc, keylen + 2))
		ret += '\n'
		return ret
	
	def helpInList(self, keylen = None):
		keylen = keylen or len(self.name)
		keylen = max(KEYLEN_MIN, keylen)
		fmtstr = '  %-' + str(keylen) + 's%s\n'
		return fmtstr % (self.name, Command.printDocs(self.doc, keylen + 2))

	def run(self, *args, **kwargs):
		raise NotImplementedError()

class Method(Command):

	def _getDocString(self):
		if not hasattr(Bioprocs, self.name):
			raise AttributeError('"%s" has no attribute "%s"' % (Bioprocs.__name__, self.name))

		method = getattr(Bioprocs, self.name)
		docstr = ''
		if hasattr(method, '__doc__'):
			docstr = method.__doc__.strip()
		return docstr

	def run(self, *args, **kwargs):
		getattr(Bioprocs(), self.name)(*args, **kwargs)

class Script(Command):

	def help(self):
		sfile = path.join(path.dirname(__file__), 'commands', self.name + '.py')
		script = imp.load_source('_script', sfile)
		return script.params.help()

	def _getDocString(self):
		sfile = path.join(path.dirname(__file__), 'commands', self.name + '.py')
		if not path.isfile(sfile):
			raise OSError('Directory "commands" has no such script: %s' % self.name)

		docstr = ''
		with open(sfile, 'r') as f:
			docstarted = None
			for line in f:
				if line.startswith('#!'): continue
				if line.startswith('#') and (docstarted or docstarted is None):
					docstarted = True
					docstr += line[1:].lstrip()
				else:
					docstarted = False
		return docstr

	def run(self, *args, **kwargs):
		sfile = path.join(path.dirname(__file__), 'commands', self.name + '.py')
		script = imp.load_source('_script', sfile)
		try:
			script.run(*args, **kwargs)
		except Exception as ex:
			raise
			self._error(str(ex))

class Process(Command):

	def __init__(self, name, prog = path.basename(sys.argv[0])):
		super(Process, self).__init__(name, prog)
		self.opts = OrderedDict([('exdir', 'The output directory.'), ('proc.xxx', ['The common config of all processes.'])])

	def _getDocString(self):
		module, procname = self.name.split('.', 1)
		pfile = path.join(path.dirname(bioprocs.__file__), module + '.py')

		if not path.isfile(pfile):
			raise ValueError('Module bioprocs has no such process: %s' % name)

		with open(pfile) as f:
			content = f.read()

		regex  = re.compile(r'(\"\"\"|\'\'\')\s+@name:\s+'+ procname +r'\s+@description:\s+([\s\S]+?)\1')
		docstr = regex.search(content)

		if not docstr:
			# try to look for it by its definition
			# pABC = Proc(desc = 'abc')
			regex2 = re.compile(procname + r'\s*=\s*Proc\s*\(.*?desc\s*=\s*(\'|\")(.+?)\1')
			docstr = regex2.search(content)
			if not docstr:
				# if it is an alias
				regex3 = re.compile(r'from \.(\w+) import .*?\b' + procname + r'\b')
				imatch = regex3.search(content)
				
				raiseOrNot = False
				if not imatch:
					regex4 = re.compile(r'from \.(\w+) import \*')
					imatch = regex4.search(content)
				
				if imatch:
					asmod  = imatch.group(1)
					pfile  = path.join(path.dirname(bioprocs.__file__), asmod + '.py')
					with open(pfile) as f:
						content = f.read()
					docstr = regex.search(content)
					if not docstr:
						raiseOrNot = True
				else:
					raiseOrNot = True

				if raiseOrNot:
					raise ValueError('Process not defined or docstring missing: %s' % self.name)
		
		blocks = Command.getblocks(docstr.group(2))

		docstr = blocks.get('doc', '')
		inputs = Command.getitems(blocks.get('input', ''))
		docstr += '@params:\n'
		for inkey, indoc in inputs.items():
			docstr += '`in.%s`: [input.%s] %s\n' % (inkey, inkey, '\n'.join(indoc).lstrip())
		outputs = Command.getitems(blocks.get('output', ''))
		for outkey, outdoc in outputs.items():
			docstr += '`out.%s`: [output.%s] %s\n' % (outkey, outkey, '\n'.join(outdoc).lstrip())
		args = Command.getitems(blocks.get('args', ''))
		for argskey, argsdoc in args.items():
			docstr += '`args.%s`: %s\n' % (argskey, '\n'.join(argsdoc).lstrip())

		return docstr

	def _createProc(self, *args, **kwargs):
		module, pname = self.name.split('.', 1)

		proc   = getattr(__import__('bioprocs.' + module, fromlist = ['bioprocs']), pname)
		config = {'proc': {'log': {'file': None}}}
		
		# get input keys
		if isinstance(proc.config['input'], dict):
			inkeys = inkeys.keys()
		else:
			inkeys = utils.split(proc.config['input'], ',')

		inkeys = [inkey.split(':')[0] for inkey in inkeys]
		input  = [''] * len(inkeys)

		for key, val in kwargs.items():
			if '.' not in key:
				setattr(proc, key, val)
			kparts = key.split('.')
			t = kparts.pop(0)
			if t == 'input' or t == 'in':
				inkey = kparts[0]
				if not inkey in inkeys:
					self._error('Unknown input key ({}) for ({}.{}), expect [{}]'.format(inkey, module, pname, ', '.join(inkeys)))
				input[inkeys.index(inkey)] = val
			elif t == 'args':
				lastpart = kparts.pop(-1)
				aval = proc.args
				for k in kparts:
					if k not in aval:
						aval[k] = {}
					aval = aval[k]
				if lastpart not in aval:
					lastpart = lastpart.replace('-', '.')
				aval[lastpart] = val
			elif t == 'proc':
				lastpart = kparts.pop(-1)
				procconf = config['proc']
				for k in kparts:
					if k not in procconf:
						procconf[k] = {}
					else:
						procconf = procconf[k]
				procconf[lastpart] = val
			else:
				self._error('Unknown argument: %s' % key)
		if not any([bool(it) for it in input]):
			self._error('No input specified.')
		setattr(proc, 'input', input)
		return proc, config

	def run(self, *args, **kwargs):
		proc, config = self._createProc(*args, **kwargs)
		PyPPL(config).start(proc).run()
    
class Bioprocs(object):

	@staticmethod
	def _isProcess(procname):
		return procname[0] == 'p' and (procname[1].isdigit() or procname[1].isupper())

	@staticmethod
	def _parseArgs(argv = sys.argv):
		ret = {'': []} # positional arguments
		argname = None
		for arg in argv:
			# if previous argument has no value, it should be regarded as bool True
			if argname and arg.startswith('-'):
				ret[argname] = True
				argname = arg[1:]
			elif argname and not arg.startswith('-'):
				if isinstance(arg, six.string_types):
					arg = arg.replace("\\n", "\n").replace("\\t", "\t")
					if arg.startswith('repr:'): arg = eval(arg[5:])
					if arg.startswith('py:'):   arg = eval(arg[3:])
				ret[argname] = arg
				argname = None
			elif not argname and arg.startswith('-'):
				argname = arg[1:]
			else:
				ret[''].append(arg)
		return ret

	@staticmethod
	def _getFileDoc(sfile, doc = '[ Module not documented ]'):
		ret = []
		with open(sfile, 'r') as f:
			docstarted = None
			for line in f:
				if line.startswith('#!'): continue
				if line.startswith('#') and (docstarted or docstarted is None):
					docstarted = True
					r = line[1:].strip()
					ret.append(r)
				elif docstarted:
					docstarted = False
		return ret

	@staticmethod
	def _getMethods():
		metname = [
			key for key, _ in inspect.getmembers(Bioprocs, predicate = inspect.ismethod)
			if not key.startswith('_') and key != 'run'
		]
		return {mname: Method(mname) for mname in metname}

	@staticmethod
	def _getScripts():
		sdir    = path.join(path.dirname(__file__), 'commands')
		scnames = [path.splitext(script)[0] for script in listdir(sdir)]
		return {scname: Script(scname) for scname in scnames}

	@staticmethod
	def _getProcesses(module = None):
		pdir = path.dirname(bioprocs.__file__)
		if module:
			modfile = path.join(pdir, module + '.py')
			if not path.isfile(modfile):
				raise ImportError('No such module: %s' % module)

			pymodule = __import__('bioprocs.%s' % module, fromlist = ['bioprocs'])
			procs    = {proc: Process(module + '.' + proc) for proc in dir(pymodule) if Bioprocs._isProcess(proc)}

			moddoc = Bioprocs._getFileDoc(modfile)
			return moddoc, procs
		else:
			modules = set([path.splitext(mfile)[0] for mfile in listdir(pdir)])
			modules = [mod for mod in modules if not mod.startswith('_') and mod not in ['utils', 'scripts', 'wxs']]
			mods    = {}
			procs   = {}
			for module in modules:
				moddoc, ps = Bioprocs._getProcesses(module)
				mods[module]  = moddoc
				procs[module] = ps
			return mods, procs

	@staticmethod
	def _getCommand(cmd):
		if '.' in cmd:
			try:
				return Process(cmd)
			except ValueError:
				sys.stderr.write('Error: no such process "%s"\n\n' % cmd)
				sys.exit(1)
		else:
			try:
				return Method(cmd)
			except AttributeError:
				try:
					return Script(cmd)
				except OSError:
					sys.stderr.write('Error: no such method or script "%s"\n\n' % cmd)
					sys.exit(1)

	def __init__(self, argv = sys.argv):
		argv         = argv[:]
		self.prog    = path.basename(argv.pop(0))
		self.command = argv.pop(0) if argv else 'help'
		self.args    = Bioprocs._parseArgs(argv)

	def run(self):
		command = Bioprocs._getCommand(self.command)

		args = self.args.copy()
		del args['']
		command.run(*self.args[''], **args)

	def _listSingleModule(self, module):
		moddoc, procs = Bioprocs._getProcesses(module)
		modlen = max([len(md) for md in moddoc]) if moddoc else 0

		ret  = '%s: %s\n' % (module, Command.printDocs(moddoc, len(module) + 2, hyphen = False))
		ret += '-' * (len(module) + 2 + min(DOCLEN_MAX, modlen)) + '\n'
		keylen = max([len(key) for key in procs.keys()])
		keylen = max(KEYLEN_MIN, keylen)
		for proc in procs.values():
			ret += proc.helpInList(keylen)
		ret += '\n'
		return ret

	def list(self, mod = None):
		"""
		List the process
		Use "{prog} list <MOD>" to list all processes of a module.
		@usage:
			{prog} list
			{prog} list [MOD]
			{prog} list [-mod MOD]
		@params:
			`mod`: The name of the module.
		"""
		if mod:
			sys.stdout.write(self._listSingleModule(mod))
		else:
			mods, _ = Bioprocs._getProcesses()
			for mod in mods.keys():
				sys.stdout.write(self._listSingleModule(mod))

	def params(self, *args, **kwargs):
		"""
		Show bioprocs.params items.
		@usage:
			{prog} params
			{prog} params [PARAM1] [PARAM2 ...]
			{prog} params [-param PARAM1 PARAM2 ...]
		@params:
			`param`: The parameter names
		"""
		if 'param' in kwargs and kwargs['param']:
			args.append(kwargs['param'])
		if not args:
			args = bioprocs.params.asDict().keys()
		ret = '\n'
		for arg in sorted(args):
			param = getattr(bioprocs.params, arg)
			ret += '%s:\n' % (arg)
			ret += '-' * (len(arg) + 1) + '\n'
			ret += '- desc:  %s\n' % Command.printDocs([param.desc], 9, hyphen = False)
			ret += '- value: %s\n' % repr(param.value)
			ret += '- type:  %s\n' % param.type.__name__
			ret += '\n'
		sys.stdout.write(ret)

	def help(self, cmd = None):
		"""
		Print this help information.
		Use "{prog} help <CMD>" to show help for commands.
		@usage:
			{prog} help
			{prog} help [CMD]
			{prog} help [-cmd CMD]
		@params:
			`cmd`: The command of the help information to show.
		"""
		if not cmd:
			methods = Bioprocs._getMethods()
			scripts = Bioprocs._getScripts()
			
			ret = '\n'
			ret += 'Usage: %s <command> [options ...]\n\n' % self.prog

			ret       += 'Method commands:\n'
			metkeylen  = max([len(m) for m in methods.keys()])
			sckeylen   = max([len(s) for s in scripts.keys()])
			keylen     = max(metkeylen, sckeylen, KEYLEN_MIN)
			for met in methods.values():
				ret += met.helpInList(keylen)
			
			ret += '\n'
			ret += 'Script commands:\n'
			for sc in scripts.values():
				ret += sc.helpInList(keylen)
			
			ret += '\n'
			ret += 'Process commands:\n'
			ret += ('  %-' + str(keylen) + 's%s\n') % ('<module.proc>', Command.printDocs([
				'Use "{prog} list" to show all processes, or', 
				'use "{prog} list <module>" to show processes of a module.'
			], keylen + 2))

			ret += '\n'
			sys.stdout.write(ret)
		else:
			sys.stdout.write(Bioprocs._getCommand(cmd).help())
	
if __name__ == '__main__':
	Bioprocs().run()

